It's [[https://adventofcode.com/2024/][advent of code]] in clojure. Have some milk and cookies: üç™ü•õüç™üç™

#+html:<details><summary>Setup</summary>
#+BEGIN_SRC emacs-lisp :results silent
(require 'ob-clojure)
(setq org-babel-clojure-backend 'cider)
#+END_SRC

sanity:
#+begin_src clojure :results silent
(+ 1 2)
#+end_src

#+begin_src clojure :results silent
(ns user
  (:require [clojure.java.shell :as shell]
            [clojure.string :as string]
            [babashka.fs :as fs]))

(defn get-input [day]
  ;; ~/.cache/aoc
  (let [year 2024
        cache-file (fs/file (fs/xdg-cache-home) (format "aoc/%s/%s.txt" year day))
        ;; https://github.com/wimglenn/advent-of-code-wim/issues/1
        session (string/trim (:out (shell/sh "bash" "-i" "-c" "echo $AOC_SESSION")))]
    (fs/create-dirs (fs/parent cache-file))
    ;; (fs/delete cache-file)
    (when-not (fs/exists? cache-file)
      (shell/sh "touch" (str (fs/strip-ext cache-file) "_example.txt"))
      (spit cache-file
            (:out (shell/sh
                   "curl" (format "https://adventofcode.com/%s/day/%s/input" year day)
                   "-X" "GET"
                   "-H" (format "Cookie: session=%s" session)))))
    (slurp cache-file)))
#+end_src
#+html:</details>

*** COMMENT Day N

#+html:<details><summary>Part 1</summary>
#+begin_src clojure :results silent
(get-input "n")
;; todo
#+end_src
#+html:</details>

#+html:<details><summary>Part 2</summary>
#+begin_src clojure :results silent
;; todo
#+end_src
#+html:</details>

*** Day 1: [[https://adventofcode.com/2024/day/1][Historian Hysteria]]

#+html:<details><summary>Part 1</summary>
#+begin_src clojure :results silent
(let [nums (map Integer/parseInt (string/split (get-input "1") #"(\n|   )"))
      list1 (sort (take-nth 2 nums))
      list2 (sort (take-nth 2 (drop 1 nums)))]
  (->> (interleave list1 list2)
       (partition 2)
       (map (partial apply -))
       (map abs)
       (apply +)))
#+end_src

Bonus: uiua

#+begin_src uiua
# Uiua 0.14.0-dev.5
&fras "1.txt"
/+‚â°‚åµ-‚ä¢‚üú‚ä£‚â°‚çÜ‚çâ‚äú(‚äú‚ãï‚ä∏‚â†@ )‚ä∏‚â†@\n
#+end_src
#+html:</details>

#+html:<details><summary>Part 2</summary>
#+begin_src clojure :results silent
(let [nums (map Integer/parseInt (string/split (get-input "1") #"(\n|   )"))
      list1 (take-nth 2 nums)
      list2 (take-nth 2 (drop 1 nums))
      freqs (frequencies list2)]
  (->> list1
       (map (fn [n] (* n (or (get freqs n) 0))))
       (apply +)))
#+end_src
#+html:</details>

*** Day 2: [[https://adventofcode.com/2024/day/2][Red-Nosed Reports]]

#+html:<details><summary>Part 1</summary>
#+begin_src clojure :results silent
(let [levels (get-input "2" true)
      levels (map #(map Integer/parseInt (string/split % #" ")) levels)]
  (->> levels
       (remove (fn [level]
                 ;; increasing/decreasing, set cast for same floor case
                 (not (or (= (sort > (set level)) level)
                          (= (sort < (set level)) level)))))
       (remove (fn [level]
                 (->> (partition 2 1 level)
                      (map (fn [[cur next]]
                             (<= 1 (abs (- cur next)) 3)))
                      (some false?))))
       (count)))
#+end_src
#+html:</details>

#+html:<details><summary>Part 2</summary>
#+begin_src clojure :results silent
(defn valid-level? [level]
  (and
   ;; increasing/decreasing
   (or (= (sort > (set level)) level)
       (= (sort < (set level)) level))
   ;; floor transition in range
   (not (->> (partition 2 1 level)
             (map (fn [[cur next]]
                    (<= 1 (abs (- cur next)) 3)))
             (some false?)))))

;; https://stackoverflow.com/a/24553906
(defn drop-nth [n coll]
  (keep-indexed #(if (not= %1 n) %2) coll))

(let [levels (get-input "2" true)
      levels (map #(map Integer/parseInt (string/split % #" ")) levels)]
  (->> levels
       (filter (fn [level]
                 (or (valid-level? level)    ; already valid?
                     ;; dampener time
                     (some valid-level?
                           (map #(drop-nth % level)
                                (-> level count range))))))
       (count)))

#+end_src

#+html:</details>

*** Day 3: [[https://adventofcode.com/2024/day/3][Mull It Over]]

#+html:<details><summary>Part 1</summary>
#+begin_src clojure :results silent
(->> (get-input "3")
     (re-seq #"mul\((\d{1,3}),(\d{1,3})\)")
     (map (fn [[_ x y]] (* (parse-long x) (parse-long y))))
     (apply +))
#+end_src
#+html:</details>

#+html:<details><summary>Part 2</summary>
#+begin_src clojure :results silent
(->> (get-input "3")
     (re-seq #"(mul|do|don't)\(((\d{1,3}),(\d{1,3}))?\)")
     (reduce (fn [state [_ op _ x y]]
               (condp = op
                 "do" (assoc state :enabled? true)
                 "don't" (assoc state :enabled? false)
                 "mul" (if (:enabled? state)
                         (update state :sum (partial + (* (parse-long x) (parse-long y))))
                         state)))
             {:enabled? true
              :sum 0})
     :sum)
#+end_src
#+html:</details>

*** Day 4: [[https://adventofcode.com/2024/day/4][Ceres Search]]

#+html:<details><summary>Part 1</summary>
#+begin_src clojure :results silent
(let [input (string/split-lines (get-input "4"))
      dirs (for [x [-1 0 1]
                 y [-1 0 1]]
             [x y])
      look (fn [[x y]] (-> input (get x []) (get y nil)))
      move (fn [[x y] [xx yy]] [(+ x xx) (+ y yy)])
      peek (fn [coord dir] (map look (reductions move coord (repeat 3 dir))))]
  (->> (for [x (range (count (first input)))
             y (range (count input))
             :when (= (look [x y]) \X)]
         (for [dir dirs]
           (= (peek [x y] dir)
              (seq "XMAS"))))
       (flatten)
       (filter true?)
       (count)))
#+end_src
#+html:</details>

#+html:<details><summary>Part 2</summary>
#+begin_src clojure :results silent
(let [input (string/split-lines (get-input "4"))
      h (count input)
      w (count (first input))
      corner1 [[-1 -1] [1 1]]
      corner2 [[-1 1] [1 -1]]
      move (fn [[x y] [xx yy]] [(+ x xx) (+ y yy)])
      look (fn [[x y]] (-> input (get x []) (get y nil)))]
  (->> (for [x (range w)
             y (range h)
             :when (= (look [x y]) \A)]
         (and (= (set "SM") (set (map #(-> % (move [x y]) look) corner1)))
              (= (set "SM") (set (map #(-> % (move [x y]) look) corner2)))))
       (filter true?)
       (count)))
#+end_src
#+html:</details>

*** Day 5: [[https://adventofcode.com/2024/day/5][Print Queue]]

#+html:<details><summary>Part 1</summary>
#+begin_src clojure :results silent
;; I should do this better later lmao
(let [[rules manuals] (string/split (get-input "5") #"\n\n")
      middle (fn [v] (nth v (quot (count v) 2)))
      rules (map (fn [rule]
                   (let [[a b] (string/split rule #"\|")]
                     [[a b] (re-pattern (format ".*%s(?!.*%s).*" b a))]))
                 (string/split-lines rules))]
  (->> (string/split-lines manuals)
       (filter (fn [manual] (every? (fn [[[a b] rule]]
                                      (if (and (string/includes? manual a)
                                               (string/includes? manual b))
                                        (re-matches rule manual)
                                        true)) rules)))
       (map #(string/split % #","))
       (map middle)
       (map parse-long)
       (reduce +)))
#+end_src
#+html:</details>

#+html:<details><summary>Part 2</summary>
#+begin_src clojure :results silent
#+end_src
#+html:</details>

*** Day 6: [[https://adventofcode.com/2024/day/6][Guard Gallivant]]

#+html:<details><summary>Part 1</summary>
#+begin_src clojure :results silent
(let [input (string/split-lines (get-input "6"))
      look (fn [[x y]] (-> input (get y []) (get x nil)))
      ;; ugh
      position (loop [x 0 y 0]
                 (if-let [found-x (->> (get input y)
                                       (keep-indexed (fn [i c] (when ((set (seq "<>^v")) c) i)))
                                       (first))]
                   [found-x y]
                   (recur x (inc y))))
      dirs [[0 -1] [1 0] [0 1] [-1 0]]]
  (loop [dir (string/index-of "^>v<" (look position))
         position position
         seen #{position}]
    (let [[x y] position
          [x- y-] (get dirs (mod dir (count dirs)))
          next [(+ x x-) (+ y y-)]]
      (condp = (look next)
        nil (inc (count seen))          ; done!
        \# (recur (inc dir) position seen)
        (recur dir next (conj seen position))))))

;; initially was building state like this:
(comment
  [obstacles position]
  (reduce (fn [[obs pos] coord]
            (condp = (look coord)
              \. [obs pos]
              \# [(conj obs coord) pos]
              [obs coord]))
          [#{} nil]
          (for [x (range (count (first input)))
                y (range (count input))]
            [x y])))
#+end_src
#+html:</details>

#+html:<details><summary>Part 2</summary>
#+begin_src clojure :results silent
(def board
  (let [input (string/split-lines (get-input "6"))
        look (fn [[x y]] (-> input (get y []) (get x nil)))]
    (-> (reduce (fn [state coord]
                  (condp = (look coord)
                    \. (update state :blanks conj coord)
                    \# (update state :blocks conj coord)
                    (update state :position (constantly [coord (string/index-of "^>v<" (look coord))]))))
                {:blocks #{} :blanks #{} :position nil}
                (for [x (range (count (first input)))
                      y (range (count input))]
                  [x y]))
        (assoc :width (count (first input)))
        (assoc :height (count input)))))

(defn check-board [new-block]
  (let [blocks (conj (:blocks board) new-block)
        dirs [[0 -1] [1 0] [0 1] [-1 0]]]
    (loop [ref (:position board)
           seen #{}]
      (let [[position dir-index] ref
            dir-index (mod dir-index (count dirs))
            [x y] position
            [x- y-] (get dirs dir-index)
            next [(+ x x-) (+ y y-)]
            within-board? (and (<= 0 (first next) (:width board))
                               (<= 0 (second next) (:height board)))]
        (cond
          (seen ref) true
          (not within-board?) nil
          (blocks next) (recur [position (inc dir-index)] (conj seen ref))
          :else (recur [next dir-index] (conj seen ref)))))) )

;; count the looping boards
(count (remove nil? (pmap check-board (:blanks board))))
#+end_src
#+html:</details>
